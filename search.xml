<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Test1</title>
    <url>/2020/07/23/Test1/</url>
    <content><![CDATA[<a id="more"></a>

<p>Referencing images or other assets using normal markdown syntax and relative paths may lead to incorrect display on archive or index pages. Plugins have been created by the community to address this issue in Hexo 2. However, with the release of Hexo 3, several new tag plugins were added to core. These enable you to reference your assets more easily in posts （我会在正文中出现哦！😜😜）</p>
<img src="/images/Test1/avatar.jpg" alt="Avatar" style="zoom:33%;" />

<p><img src="/images/Test1/timg.jpg" alt="兰波"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Test2</title>
    <url>/2020/07/25/Test2/</url>
    <content><![CDATA[<img src="/images/Test2/avatar.jpg" alt="avatar" style="zoom:33%;" />]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>类设计基础（一）</title>
    <url>/2020/07/25/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>​        类是对某一类事物的抽象描述，对象是某一类中一个或多个具体的事物。</p>
<p>​        类和对象在使用前必须先定义后使用，如同变量的定义和使用。</p>
<h2 id="封装和隐藏"><a href="#封装和隐藏" class="headerlink" title="封装和隐藏"></a>封装和隐藏</h2><p><u>        封装</u>就是将对象的属性（域/数据）和行为（方法/函数）定义在一起，形成一个集合。封装的结果得到一个类。</p>
<p>例如： 对学生类的封装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String id;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> gender;<span class="comment">//性别</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">float</span> score;<span class="comment">//成绩</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//……&#125;//方法，显示学生信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        封装并不是简单地将对象的属性和行为定义在一起，而是要对属性和行为起到一定的保护作用，这种保护作用称<u>隐藏</u>。</p>
<p>​        不同类的对象封装的结果不同，即使是同一类的对象在不同环境（系统）中封装结果也会不同。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">	域列表;</span><br><span class="line">	方法列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">​	<span class="keyword">int</span> x,y;<span class="comment">//域，点的位置</span></span><br><span class="line">​	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="comment">//方法，获得x分量</span></span><br><span class="line">​		<span class="keyword">return</span> x;</span><br><span class="line">​	&#125;</span><br><span class="line">    </span><br><span class="line">​	<span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123; <span class="comment">//方法，获得y分量</span></span><br><span class="line">​		<span class="keyword">return</span> y;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> offsetX,<span class="keyword">int</span> offsetY)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="comment">//方法，对点平移</span></span><br><span class="line">​		x+=offsetX;</span><br><span class="line">​		y+=offsetY;</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="域的定义"><a href="#域的定义" class="headerlink" title="域的定义"></a>域的定义</h2><p>​        域的最基本定义方法与变量定义一样。它的基本定义形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 域名<span class="number">1</span>[=初值<span class="number">1</span>],域名<span class="number">2</span>[=初值<span class="number">2</span>],……,域名n[=初值n];</span><br></pre></td></tr></table></figure>

<p>​        定义域时可以给出域的初值。在定义域时，如果不给出域的初值，域也会被初始化。</p>
<p>​        域的定义形式与一般变量的定义基本相同。但是域定义在类中，是类的成员，可以称<strong>成员变量</strong>，一般变量是定义在方法中，称为<strong>局部变量</strong>。它们的作用范围不同。</p>
<h2 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h2><h3 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h3><p>​        方法用于对数据进行的处理。</p>
<p>​        一般地，数据处理完成后应将处理的结果数据返回。如果返回数据，该数据一定有类型，这个类型就是定义方法时声明的“方法类型”。所以，<strong>“方法类型”是方法返回值的类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法类型 方法名(形式参数表列) &#123; <span class="comment">//形参为变量，可有可无；调用方法后输出的参数为实参。</span></span><br><span class="line">​	<span class="comment">//方法体——若干语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p>​        return语句用在方法中。当执行到return语句时，这个方法执行结束并返回到上一个方法的调用处。</p>
<p>​        方法的返回值可用return语句实现。return语句的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> 表达式;</span><br></pre></td></tr></table></figure>

<p>​        方法也可以不返回值。如果方法不返回值，则定义方法时应该将“方法类型”声明为“void”，明确表示该方法不返回值。</p>
<p>​    <strong>如果方法的类型为“void”，则在方法中一定不能有语句“return 表达式;”</strong>，但是可以使用语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><p>​        “方法名”是方法的标识，执行一个方法是通过“方法名”完成的。</p>
<h3 id="形式参数列表"><a href="#形式参数列表" class="headerlink" title="形式参数列表"></a>形式参数列表</h3><p>​        如果执行一个方法时，需要给方法一些原始数据，则可以通过“形式参数列表”来完成。</p>
<p>​        “形式参数表列”的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型<span class="number">1</span> 形式参数<span class="number">1</span>, 数据类型<span class="number">2</span> 形式参数<span class="number">2</span>,……,数据类型n 形式参数n</span><br></pre></td></tr></table></figure>

<p>​        根据需要，“形式参数列表”可以有也可以没有。如果定义方法时没有“形式参数列表”，则执行方法不需要给出实际数据；否则，一定要给出相应的实际数据。</p>
<p>​        调用方法时给出的参数称为实际数据。实际数据又称“实际参数”（简称实参），<strong>实参可以是常量、变量或表达式，但形参一定是变量。</strong></p>
<h3 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h3><p>​        “方法体”是方法的具体实现。想让方法完成什么样的运算，就可以在方法体中定义相应的语句。</p>
<h3 id="方法执行"><a href="#方法执行" class="headerlink" title="方法执行"></a>方法执行</h3><p>​        执行一个方法称为方法的调用。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>​        在一个作用域（如一个类中）内定义的多个同名方法称为<strong>方法的重载</strong>。</p>
<p>​        方法重载时要求方法的形式参数互不相同，如形参个数互不相同，或者形参个数相同，但只要有一对对应的参数的类型不同。</p>
<p>​        方法重载不能靠“方法类型”来区分。</p>
<p>​        当方法调用时，只要给出实际参数，运行时系统就会自动调用相应的方法而不需程序判断。<br>一般地，具有相似性质或功能的运算用重载方法。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">//三个重载方法的形参互不相同</span></span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m=max(x,y);<span class="comment">//调用第1个max方法找前两个数最大数</span></span><br><span class="line">​	<span class="keyword">return</span> m&gt;z?m:z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">​	<span class="keyword">int</span> m=a[<span class="number">0</span>];</span><br><span class="line">​	<span class="keyword">for</span>(<span class="keyword">int</span> x:a)</span><br><span class="line">​		m=m&gt;x?m:x; </span><br><span class="line">		<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法的递归"><a href="#方法的递归" class="headerlink" title="方法的递归"></a>方法的递归</h2><p>​        方法的调用有两种形式，一种是<strong>嵌套调用</strong>，另一种是<strong>递归调用</strong>。</p>
<p>​        递归方法是一个方法在执行过程中直接或间接调用了自身。通过递归调用，可以将问题简化为规模缩小了的同类问题的子问题。</p>
<p>​        使用方法递归调用时，应满足三个要求：</p>
<ul>
<li><p>一是每一次的调用都会使问题得到简化；</p>
</li>
<li><p>二是前后调用应该有一定的关系，通常是前一次调用要为后一次调用准备好条件（数据）；</p>
</li>
<li><p>三是在问题规模极小时应该终止递归调用，以避免无限递归调用，也就是应该有递归调用结束的条件。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>类设计基础（二）</title>
    <url>/2020/07/25/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="对象的声明与创建"><a href="#对象的声明与创建" class="headerlink" title="对象的声明与创建"></a>对象的声明与创建</h2><p>​        定义了类之后，就可以用类定义对象（object）了。对象又可以称为实例（instance）。</p>
<h3 id="对象的声明"><a href="#对象的声明" class="headerlink" title="对象的声明"></a>对象的声明</h3><p>​        对象声明的形式：</p>
<p>​            <strong>类（名）    对象名表列;</strong><br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p1,p2;</span><br></pre></td></tr></table></figure>

<p>​        声明对象后还必须创建对象才能使用对象。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>​        对象创建的形式：</p>
<p>​            <strong>new    构造方法()</strong><br>如：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Point</span>();</span><br></pre></td></tr></table></figure>

<p>​        可以通过赋值的形式给这个对象一个名字。如前面定义的对象名p1，可以用p1表示创建的对象：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">p1</span> = new Point()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>​        使用对象的形式：</p>
<p>​            <strong>对象名.域</strong></p>
<p>​            <strong>对象名.方法名([实际参数表列])</strong></p>
<p><strong><em>创建一个对象后，这个对象就有自己的属性和行为。通过对象名访问域或方法，只能是对象本身的域或方法，而不能是其它对象的域或方法。</em></strong></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>​        创建对象时通过<em>“new”</em>运算符调用类中的构造方法。如果类中没有相应的构造方法，则不能创建对象。所以，在定义类时应该定义<strong>构造方法</strong>。</p>
<p><strong><em>在一个类中可以定义多个构造方法，形成构造方法的重载。</em></strong></p>
<p><strong><em>利用重载的构造方法可以创建不同初始状态的对象。</em></strong></p>
<p>​        构造方法的定义形式：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">方法名<span class="comment">([形参表列])</span> &#123;</span><br><span class="line"><span class="comment">//…..方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的内存模型"><a href="#对象的内存模型" class="headerlink" title="对象的内存模型"></a>对象的内存模型</h2><p>​        语句：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">p2</span> = new Point(<span class="number">5</span>,<span class="number">8</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>​        创建一个Point类的对象并用对象名p2表示。</p>
<p>​        用对象名表示对象，就是对象在内存中的表示方法。如图4-7所示。</p>
<img src="/images/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/%E5%9B%BE4-7%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="图4-7 对象的内存模型" style="zoom:67%;" />

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>​        this是当前对象，也可以看作是当前对象的别名（当前对象名）。</p>
<p>​        哪一对象调用这个方法，this就表示的是哪一个对象。</p>
<p>​        因为<strong><em>当局部变量与域名重名时，在方法中只能访问到局部变量。如果想访问同名的域，就需要在域名前加上this，表示是当前对象中的域，而不是局部变量。</em></strong></p>
<p>例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">​	<span class="keyword">int</span> x,y;<span class="comment">//域，点的位置</span></span><br><span class="line">​	Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y) &#123; <span class="comment">//有两个参数的构造方法</span></span><br><span class="line">​		<span class="keyword">this</span>.x = x;</span><br><span class="line">​		<span class="keyword">this</span>.y = y;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​		System.out.<span class="built_in">println</span>(<span class="string">"("</span>+x+<span class="string">","</span>+y+<span class="string">")"</span>);</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="基本数据类型作方法的参数"><a href="#基本数据类型作方法的参数" class="headerlink" title="基本数据类型作方法的参数"></a>基本数据类型作方法的参数</h3><p>​        如果参数是基本数据类型，当这个方法被调用时，运行时系统会为形式参数开辟新的存储单元。所以，即使实际参数是一个变量，它与形参也不是同一个存储单元，形参的值改变了，实际参数的值不会变化。</p>
<h3 id="对象名作方法的参数"><a href="#对象名作方法的参数" class="headerlink" title="对象名作方法的参数"></a>对象名作方法的参数</h3><p>​        因为对象名的值就是对象在内存中的地址，所以，当对象名作方法的参数时，是将对象的地址传递到被调方法中。这样，在被调用方法中的形参与主调方法中的实参指的是同一个对象。</p>
<h3 id="数组名作方法的参数"><a href="#数组名作方法的参数" class="headerlink" title="数组名作方法的参数"></a>数组名作方法的参数</h3><p>数组名表示数组在内存中的起始地址。所以用数组名作方法的参数时，是将数组在内存中的<strong>起始地址</strong>传递到被调方法中，在被调用方法中就可以通过数组起始地址访问到数组中的每一个元素。</p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><h3 id="对象数组的定义"><a href="#对象数组的定义" class="headerlink" title="对象数组的定义"></a>对象数组的定义</h3><p>​        先声明一个对象数组名。声明形式：</p>
<p>​            <strong>类名    对象数组名[];</strong></p>
<p>​        再创建对象数组，形式：</p>
<p>​            <strong>对象数组名    =    new 类名[数组长度];</strong></p>
<p>​        例如，平面上有若干个点，可以用一个点类的对象数组表示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">Point</span> p[] = <span class="built_in">new</span> <span class="type">Point</span>[<span class="number">10</span>]; //是否与<span class="type">Point</span> p[]; p[]=<span class="built_in">new</span> <span class="type">Point</span>[<span class="number">10</span>];等价？</span><br></pre></td></tr></table></figure>

<p>​        还需要调用构造方法创建每一个对象。例如，让对象数组p中的每个元素都表示一个对象，可以使用循环：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;p.<span class="built_in">length</span>;<span class="built_in">i</span>++)</span><br><span class="line">	p[<span class="built_in">i</span>]=new Point();</span><br></pre></td></tr></table></figure>

<h3 id="对象数组初始化"><a href="#对象数组初始化" class="headerlink" title="对象数组初始化"></a>对象数组初始化</h3><p>​        在声明数组时就使数组中的每一个元素表示一个对象，称为对象数组初始化。        </p>
<p>​        对象数组初始化形式：</p>
<p>​            <strong>类名    对象数组名[]    =    {对象表列};</strong></p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>​        关键字static用于修饰域和方法。用static修饰的域和方法称为类域和类方法，或称为静态域和静态方法。</p>
<h3 id="static修饰域"><a href="#static修饰域" class="headerlink" title="static修饰域"></a>static修饰域</h3><p>​        这种方式有两个缺点，一个是容易遗漏，二是没有做到数据封装。</p>
<p>​        将计数器变量定义在类中，每创建一个对象时，就在构造方法中使计数器增1，这样可以保证不遗漏，并做到数据封装。</p>
<p>​        <em>程序中共创建了5个对象，每个对象的counter都是1。采用这种封装方式也达不到目的。</em></p>
<p>​        <em>可以用关键字static修饰域。当用static修饰一个或多个域后，不论用这个类创建多少个对象，这些对象都有共同的一个或多个域，而不是每个对象独有的域。</em></p>
<p>​        声明静态域的形式：</p>
<p>​        数据类型 static 域名[=初值];</p>
<p>​        一次可以声明多个静态域，默认值（不初始化）为0。</p>
<p>​        因为静态域是一个类的所有对象的共同属性，所以又可以将静态域称为类域，可以通过类名直接访问，如例4-16中：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">​	<span class="keyword">int</span> x,y;</span><br><span class="line">​	**<span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;**<span class="comment">//不初始化也是0（默认）</span></span><br><span class="line"></span><br><span class="line">​	Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y) &#123;</span><br><span class="line">​		<span class="keyword">this</span>.x=x;</span><br><span class="line">​		<span class="keyword">this</span>.y=y;</span><br><span class="line">​		counter++;<span class="comment">//创建对象后增加1</span></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​		System.out.<span class="built_in">println</span>(<span class="string">"("</span>+x+<span class="string">","</span>+y+<span class="string">")"</span>);</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example4_16</span> &#123;</span></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> args[])</span> </span>&#123;</span><br><span class="line">​		<span class="comment">//可以通过类名访问静态域</span></span><br><span class="line">​		System.out.<span class="built_in">println</span>(<span class="string">"开始时对象数："</span>+**Point.counter**);</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        多数情况下应该通过类名访问，因为是类的属性。</p>
<h3 id="static修饰方法"><a href="#static修饰方法" class="headerlink" title="static修饰方法"></a>static修饰方法</h3><p>​        static修饰的方法称为类方法或静态方法，可以通过对象名访问，更多的是通过类名访问。</p>
<p>​        定义类方法的主要目的是用类方法访问类域。定义类方法的形式：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static 方法类型 方法名(<span class="selector-attr">[形参表列]</span>) &#123;</span><br><span class="line"><span class="comment">//……方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Deprecated注解"><a href="#Deprecated注解" class="headerlink" title="@Deprecated注解"></a>@Deprecated注解</h2><p>​        注解用于对程序或数据进行说明。</p>
<p>​        @Deprecated是注解中的一种，表示它所注解的域或方法已经过时，不建议再使用。当然，使用也可以。<br>使用时，将“@Deprecated”放在被注解的域或方法的前面。</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">​	<span class="keyword">int</span> x,y;</span><br><span class="line">​	<span class="meta">@Deprecated</span><span class="comment">//表示counter过时</span></span><br><span class="line">​	<span class="keyword">static</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">​	Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y) &#123;</span><br><span class="line">​		setPosition(x,y);</span><br><span class="line">​		counter++;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">​		<span class="keyword">this</span>.x=x;</span><br><span class="line">​		<span class="keyword">this</span>.y=y;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="meta">@Deprecated</span><span class="comment">//表示move方法过时</span></span><br><span class="line">​	<span class="function"><span class="keyword">void</span> <span class="title">moveTo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//移动到(x,y) &#123;</span></span></span><br><span class="line"><span class="function">​		<span class="keyword">this</span>.x</span>=x;</span><br><span class="line">​		<span class="keyword">this</span>.y=y;</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​		System.out.println(<span class="string">"("</span>+x+<span class="string">","</span>+y+<span class="string">")"</span>);</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>类设计基础（三）</title>
    <url>/2020/07/25/%E7%B1%BB%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h1><p>​        封装时用适当的保护修饰词就可以对域或方法起到保护作用。</p>
<p>​        Java中保护修饰词包括private（私有的）、protected（保护的）和public（公有的），定义类时用这些修饰词就可以对域或方法设置保护权限。</p>
<h2 id="private修饰成员"><a href="#private修饰成员" class="headerlink" title="private修饰成员"></a>private修饰成员</h2><p>​        用关键字private修饰的成员称为私有成员。private修饰域的形式：</p>
<p>​            <strong>private 数据类型    域名;</strong></p>
<p>​        private修饰方法的形式：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 方法类型 方法名([形参表列]) &#123;</span><br><span class="line"><span class="comment">//……方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>私有成员只能被所在类中的方法访问，类外的其它任何方法或对象都不能访问，所以私有成员具有最高的保护权限。</em></strong></p>
<p><strong><em>一般地，域的访问权限应该声明为private，以便对数据起到保护作用。</em></strong></p>
<h2 id="public修饰成员"><a href="#public修饰成员" class="headerlink" title="public修饰成员"></a>public修饰成员</h2><p>​        用关键字public修饰的成员称为公有成员。public修饰域的形式：</p>
<p>​            <strong>public    数据类型    域名;</strong></p>
<p>​        public修饰方法的形式:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 方法类型 方法名([形参表列])	&#123;</span><br><span class="line"><span class="comment">//……方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>公有成员可以被所在类的其它方法访问；可以在类体外通过对象名直接访问；</em></strong></li>
<li><strong><em>可以被同一包中或不同包中的子类继承，并且可以被子类中的方法直接访问；</em></strong></li>
<li><strong><em>还可以在子类的类体外通过子类的对象名直接访问。一般地，成员方法的保护权限应该声明为public，以使对象能够与其它类的对象进行适当的通讯。</em></strong></li>
</ul>
<h2 id="protected修饰成员"><a href="#protected修饰成员" class="headerlink" title="protected修饰成员"></a>protected修饰成员</h2><p>​        用关键字protected修饰的成员称为保护成员。protected修饰域的形式：</p>
<p>​            <strong>protected    数据类型    域名;</strong></p>
<p>​        protected修饰方法的形式:</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> 方法类型 方法名([形参表列]) &#123;</span><br><span class="line"><span class="comment">//……方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><em>保护成员可以被所在类的其它方法访问；</em></strong></li>
<li><strong><em>被子类继承后，可以被子类中的方法直接访问；</em></strong></li>
<li><strong><em>在同一个包中，在类体外可以通过对象名直接访问；</em></strong></li>
<li><strong><em>不是同一包中的非子类，不能通过对象名直接访问（子类的概念参见第5章）。</em></strong></li>
</ul>
<h2 id="默认的访问权限"><a href="#默认的访问权限" class="headerlink" title="默认的访问权限"></a>默认的访问权限</h2><p>​        在域或方法前不加任何访问限定词，则域或方法的访问权限是默认的。</p>
<ul>
<li><p><strong><em>默认访问权限的域或方法可以被类中的其它方法直接访问；</em></strong></p>
</li>
<li><p><strong><em>在这个类所在的包中，可以在类体之外通过对象名直接访问。</em></strong></p>
</li>
<li><p><strong>默认的域或方法具有包的访问权限，利用包的访问权限，可以提高访问的灵活性。</strong></p>
</li>
</ul>
<p>  表4.1列出了访问权限的作用范围。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">默认的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h2 id="public修饰类"><a href="#public修饰类" class="headerlink" title="public修饰类"></a>public修饰类</h2><p>​        关键字public还可以修饰类，使类成为公共类。</p>
<p>​        公共类可以被任何其它包中的类访问，公共类中的公有成员也可以被任何其它包中的类访问。</p>
<p>​        一个Java源程序文件中可以定义多个类，但是最多只能有一个类是public类。</p>
<h1 id="对象组合"><a href="#对象组合" class="headerlink" title="对象组合"></a>对象组合</h1><p><strong><em>如果一个类中的域是由其它类所定义的对象，这个类称为组合类，组合类所定义的对象称为组合对象。</em></strong></p>
<p><strong><em>通过对象组合，可以实现代码重用，可以使复杂问题简单化。</em></strong></p>
<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p>​        在类的内部还可以定义类，称为嵌套类（nested classes）。</p>
<p>​        如果嵌套类前面有关键字static，则称为静态嵌套类（static nested classes），否则称为内部类（inner classes）。</p>
<p>​        内部类又可以分局部类（local classes）和匿名类（anonymous classes）。</p>
<p>​        在方法中可以<strong>定义类</strong>，这样的类称为<strong>局部类</strong>。匿名类实际上是一个类的子类，关于匿名类的内容参见第5章。</p>
<p>​        如果一个类只在某一个地方使用一次，则应定义为内部类。使用内部类可以提高封装性、可读性和可维护性，因为类的定义与使用在一起（它们“距离比较近”）。</p>
<p>​        嵌套类的定义形式与非嵌套类的定义形式基本相同，在嵌套类中可以定义域和方法。</p>
<p>​        <strong><em>可以将嵌套的类看作外层类中的一个成员，所以它可以访问外层类中的任何成员。</em></strong></p>
<h1 id="Java的包"><a href="#Java的包" class="headerlink" title="Java的包"></a>Java的包</h1><p>​        package用于定义包，import用引入包中的类。</p>
<p>​        包是对类的一种管理方式。开发Java程序时，可以将功能相近或相似的类放在一个包中，其它功能相近或相似的类再放在另一个包中，如同管理文件、对文件进行分类。</p>
<p>​        如果想使用包中已经有的类，可以使用import语句。import引入类后，就相当于在当前类中定义了相应的类，在程序中就可以用类创建对象了。</p>
<h2 id="package语句"><a href="#package语句" class="headerlink" title="package语句"></a>package语句</h2><p>​        package语句可以将当前程序文件中的类放到指定的包中。它的使用形式：</p>
<p>​            <strong>package    包名[.子包名1[.子包名2[……]]];</strong></p>
<p>​        <em>package必须放在第一行，而且最多只能有一条package语句。</em></p>
<p>​        如果程序中没有package，则将类放在源文件所在的文件夹中（默认包）。</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><p>​        import将其它包中的类引入当前程序文件中。它的使用形式：</p>
<p>​            <strong>import    包名[.子包名1[.子包名2[…]]].类名;</strong></p>
<p>​        将包中名为“类名”的类引入到当前程序文件中。或：</p>
<p>​            <strong>import    包名[.子包名1[.子包名2[…]]].*;</strong></p>
<p>​        将“包名”（或“子包n”）包中的所有类引入到当前程序文件中，但不包括“包名”（或“子包n”）中的子包。</p>
<p>​        import static使用形式：</p>
<p>​            <strong>import static 类名.静态成员;</strong></p>
<p>​        可以将“类名”类中的“静态成员”引入到当前程序中，然后直接使用“静态成员”就可以了。或：</p>
<p>​            <strong>import static 类名.*;</strong></p>
<p>​        可以将“类名”类中的所有静态成员引入到当前程序中。</p>
<p>例：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;<span class="comment">//引入System中的所有静态成员</span></span><br><span class="line">​	<span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.<span class="literal">PI</span>;<span class="comment">//只引入Math类中的静态域PI</span></span><br><span class="line">​	<span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.<span class="built_in">sort</span>;<span class="comment">//只引入Arrays类中的静态方法sort</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
</search>
